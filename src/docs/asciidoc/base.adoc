= Notions de base
ifndef::masterdoc[]
include::meta.adoc[]
include::attributes.adoc[]
endif::masterdoc[]

== Syntaxe
* Java possède une syntaxe proche du C
** se retrouve à tous les niveaux (commentaires, types, opérateurs, ...)
** chaque instruction se termine par un `;`
** Java différencie majuscules et minuscules
* Commentaires
`/* ... */`:: le texte entre `/*` et `*/` est ignoré
`// ...`:: le texte jusqu'à la fin de la ligne est ignoré

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html[Lexical Structure]

== Types primitifs
Un _type primitif_ est un type de base du langage, i.e. non défini par l'utilisateur.

IMPORTANT: *En Java, les valeurs de ces types ne sont pas des objets*.

`boolean`:: `true` ou `false`
`byte`:: entier signé sur 8 bits (-128 à 127)
`short`:: entier signé sur 16 bits (-32768 à 32767)
`int`:: entier signé sur 32 bits (-2^31^ à 2^31^-1)
`long`:: entier signé sur 64 bits (-2^63^ à 2^63^-1)
`float`:: nombre en virgule flottante simple précision (32 bits IEEE 754)
`double`:: nombre en virgule flottante double précision (64 bits IEEE 754)
`char`:: caractère Unicode sur 16 bits de `\u0000` à `\uffff`

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.2[Primitive Types and Values]

== Littéraux
Un _littéral_ est la représentation dans le code source d'une valeur d'un type.

Entiers:: `123` de type `int`, `123L` de type `long`, `0x123F` en hexadécimal, `0b101` en binaire (depuis Java SE 7)
Flottants:: `1.23E-4` de type `double`, `1.23E-4F` de type `float`
Booléens:: `true` ou `false`
Caractères:: `'a'`, `'\t'` ou `'\u0000'`
Chaînes:: `"texte"`
IMPORTANT: le type chaîne de caractères n'est pas un type primitif : les chaînes de caractères sont des instances de la classe https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html[`java.lang.String`]
Null:: `null` (valeur des références non initialisées)

.Remarques
* Depuis Java SE 7, il est possible d'inclure le caractère `_` dans les littéraux numériques pour en améliorer la lisibilité

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.10[Literals]

== Variables
Une _variable_ permet d'associer un nom (identifiant) à une valeur.

En Java, la valeur peut être directement la valeur d'un type primitif ou une _référence_.

.Exemples de déclarations et initialisations de variables pour des types primitifs
[source,java,indent=0]
----
include::{tstdir}/base/BaseTest.java[tag=base-var-decl]
----

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.12[Variables]

== Références
* Les variables de type tableau, énumération, objet ou interface sont en fait des _références_
* La valeur d'une telle variable est une _référence vers_ (_l'adresse de_) une donnée
* Dans d'autres langages, une référence est appelée _pointeur_ ou _adresse mémoire_
* En Java, la différence réside dans le fait qu'on ne manipule pas directement l'adresse mémoire: le nom de la variable est utilisé à la place
** pas d'arithmétique des pointeurs en Java
** les références assurent une meilleure sécurité (moins d'erreurs de programmation)
* L'association (l'affectation) d'une donnée à une variable _lie_ l'identificateur et la donnée

.Une référence contient un pointeur vers un objet
[ditaa, "java-reference",svg]
----
 unObjet
 +-----+    /------\
 |     +--->|cGRE  |
 +-----+    |      |
            |      |
            \------/
----

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.3[Reference Types and Values]

== Gestion de la mémoire dans la JVM
* Les variables locales (types primitifs et références vers des objets du tas) sont créées sur la pile (_stack_)
* Lors de la création d'un objet, la mémoire est allouée dans une zone mémoire appelée le _tas_ (_heap_)
* La libération de la mémoire est automatique et gérée par le _ramasse-miette_ (_garbage collector_)
** le GC s'exécute lorque certaines conditions sont réunies
* Certains paramètres de la JVM permettent de contrôler le GC et les zones mémoires (`-mx`|`-Xmx`, `-XX:+UseParallelGC`, ...)

NOTE: https://docs.oracle.com/en/java/javase/14/gctuning/[HotSpot Virtual Machine Garbage Collection Tuning Guide]

== Tableaux
* Un _tableau_ est une structure de données regroupant plusieurs valeurs de même type
* La taille d'un tableau est déterminée lors de sa création (à l'exécution)
* La taille d'un tableau ne varie pas par la suite
* Un tableau peut contenir des références
** tableau d'objets ou tableau de tableaux
** permet de créer des tableaux à plusieurs dimensions

.http://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html[The Java Tutorials: Arrays]
image::https://docs.oracle.com/javase/tutorial/figures/java/objects-tenElementArray.gif[Un tableau en Java]

NOTE: https://docs.oracle.com/javase/specs/jls/se14/html/jls-10.html[Arrays]

=== Déclaration et création de tableaux
* La déclaration d'une variable de type tableau se fait en ajoutant `[]` au type des éléments
+
WARNING: une déclaration n'alloue pas de mémoire mais juste une référence
+
[source,java,indent=0]
----
int[] unTableau;
----

* La création du tableau se fait en utilisant l'opérateur `new` suivi du type des éléments du tableau et de sa taille entre `[]`
+
[source,java,indent=0]
----
new int[10];
----

* La référence retournée par `new` peut être liée à une variable
+
[source,java,indent=0]
----
int[] unTableau = new int[10];
----

* Il est possible de créer et d'initialiser un tableau en une seule étape
+
[source,java,indent=0]
----
int[] unTableau = { 1, 5, 10 };
----

=== Manipulation de tableaux
* L'accès aux éléments d'un tableau se fait en utilisant le nom du tableau suivi de l'indice entre `[]` (exemple: `unTableau[2]`)
* La taille d'un tableau peut être obtenue en utilisant la propriété `length` (exemple: `unTableau.length`)
* La méthode de classe `arraycopy` de `System` permet de copier efficacement un tableau

.Exemples de manipulations de tableaux
[source,java,indent=0]
----
include::{tstdir}/base/ArrayTest.java[tag=base-arrays]
----
<1> les tableaux `arrayOfFiveZeros` et `anArray` contiennent les mêmes éléments mais ne sont pas identiques, i.e. ils ne référencent pas le même objet
<2> les tableaux `anArray` et `theSameArray` sont identiques, i.e. ils référencent le même objet
<3> comme `anArray` et `theSameArray` sont identiques, la modification est visible par l'intermédiaire des deux références
<4> même cas que 1
<5> `theSameArray` référence maintenant `anotherArray` donc `theSameArray` et `anotherArray` sont identiques mais `theSameArray` et `anArray` ne le sont plus
<6> comme `theSameArray` et `anotherArray` sont identiques, la modification est visible par l'intermédiaire des deux références mais `anArray` n'a pas été modifié

== Expressions, instructions et blocs
NOTE: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html[Operators], https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html[Expressions, Statements, and Blocks], https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html[Control Flow Statements], https://docs.oracle.com/javase/specs/jls/se14/html/jls-15.html[Expressions], https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html[Blocks and Statements]
