= Notions de base
ifndef::masterdoc[]
include::meta.adoc[]
include::attributes.adoc[]
endif::masterdoc[]

== Syntaxe
* Java possède une syntaxe proche du C
** se retrouve à tous les niveaux (commentaires, types, opérateurs, ...)
** chaque instruction se termine par un `;`
** Java différencie majuscules et minuscules
* Commentaires
+
[horizontal]
`/* ... */`:: le texte entre `/* et */` est ignoré
`// ...`:: le texte jusqu'à la fin de la ligne est ignoré

NOTE: {jlsurl}/jls-3.html[Lexical Structure]

== Types primitifs
Un _type primitif_ est un type de base du langage, i.e. non défini par l'utilisateur.

WARNING: *En Java, les valeurs de ces types ne sont pas des objets*.

[horizontal]
`boolean`:: `true` ou `false`
`byte`:: entier signé sur 8 bits (-128 à 127)
`short`:: entier signé sur 16 bits (-32768 à 32767)
`int`:: entier signé sur 32 bits (-2^31^ à 2^31^-1)
`long`:: entier signé sur 64 bits (-2^63^ à 2^63^-1)
`float`:: nombre en virgule flottante simple précision (32 bits IEEE 754)
`double`:: nombre en virgule flottante double précision (64 bits IEEE 754)
`char`:: caractère Unicode sur 16 bits de `\u0000` à `\uffff`

NOTE: {jlsurl}/jls-4.html#jls-4.2[Primitive Types and Values]

== Littéraux
Un _littéral_ est la représentation dans le code source d'une valeur d'un type.

[horizontal]
Entiers:: `123` de type `int`, `123L` de type `long`, `0x123F` en hexadécimal, `0b101` en binaire ({J7})
Flottants:: `1.23E-4` de type `double`, `1.23E-4F` de type `float`
Booléens:: `true` ou `false`
Caractères:: `'a'`, `'\t'` ou `'\u0000'`
Chaînes:: `"texte"`
+
WARNING: Même si un littéral existe, le type _chaîne de caractères_ n'est pas un type primitif : les chaînes de caractères sont des instances de la classe {apiurl}/java.base/java/lang/String.html[`java.lang.String`].
Null:: `null` (valeur des références non initialisées)

.Remarques
* Il est possible d'inclure le caractère `_` dans les littéraux numériques pour en améliorer la lisibilité ({J7})

NOTE: {jlsurl}/jls-3.html#jls-3.10[Literals]

== Variables
* Une _variable_ permet d'associer un nom (identifiant) à une valeur.
* En Java, la valeur peut être directement la valeur d'un type primitif ou une _référence_.

.Exemples de déclarations et initialisations de variables pour des types primitifs
[source,java,indent=0]
----
include::{tstdir}/base/BaseTest.java[tag=base-var-decl]
----

NOTE: {jlsurl}/jls-4.html#jls-4.12[Variables]

== Références
* Les variables de type tableau, énumération, objet ou interface sont en fait des _références_
* La valeur d'une telle variable est une _référence vers_ (_l'adresse de_) une donnée
* Dans d'autres langages, une référence est appelée _pointeur_ ou _adresse mémoire_
* En Java, la différence réside dans le fait qu'on ne manipule pas directement l'adresse mémoire : le nom de la variable est utilisé à la place
** pas d'arithmétique des pointeurs en Java
** les références assurent une meilleure sécurité (moins d'erreurs de programmation)
* L'association (l'affectation) d'une donnée à une variable _lie_ l'identificateur et la donnée

.Une référence contient un pointeur vers un objet
[ditaa, "java-reference",svg]
----
 unObjet
 +-----+    /------\
 |     +--->|cGRE  |
 +-----+    |      |
            |      |
            \------/
----

NOTE: {jlsurl}/jls-4.html#jls-4.3[Reference Types and Values]

== Gestion de la mémoire dans la JVM
* Les variables locales (types primitifs et références vers des objets du tas) sont créées sur la pile (_stack_)
* Lors de la création d'un objet, la mémoire est allouée dans une zone mémoire appelée le _tas_ (_heap_)
* La libération de la mémoire est automatique et gérée par le _ramasse-miette_ (_garbage collector_)
** le GC s'exécute lorque certaines conditions sont réunies
* Certains paramètres de la JVM permettent de contrôler le GC et les zones mémoires (`-mx`|`-Xmx`, `-XX:+UseParallelGC`, ...)

NOTE: {jseurl}/gctuning/[HotSpot Virtual Machine Garbage Collection Tuning Guide]

== Tableaux
* Un _tableau_ est une structure de données regroupant plusieurs valeurs de même type
* La taille d'un tableau est déterminée lors de sa création (à l'exécution) et ne varie pas par la suite
* Un tableau peut contenir des références
** tableau d'objets ou tableau de tableaux
** permet de simuler des tableaux à plusieurs dimensions

.{tutourl}/java/nutsandbolts/arrays.html[The Java Tutorials: Arrays]
image::{tutourl}/figures/java/objects-tenElementArray.gif[Un tableau en Java]

NOTE: {jlsurl}/jls-10.html[Arrays]

=== Déclaration et création de tableaux
* La déclaration d'une variable de type tableau se fait en ajoutant `[]` au type des éléments
+
[source,java,indent=0]
----
int[] unTableau;
----
+
WARNING: une telle déclaration n'alloue pas de mémoire mais juste une référence sur la pile
* La création du tableau se fait en utilisant l'opérateur `new` suivi du type des éléments du tableau et de sa taille entre `[]`
+
[source,java,indent=0]
----
new int[10];
----
* La référence retournée par `new` peut être liée à une variable
+
[source,java,indent=0]
----
int[] unTableau = new int[10];
----
* Il est possible de créer et d'initialiser un tableau en une seule étape
+
[source,java,indent=0]
----
int[] unTableau = { 1, 5, 10 };
----

=== Manipulation de tableaux
* L'accès aux éléments d'un tableau se fait en utilisant le nom du tableau suivi de l'indice entre `[]` (exemple: `unTableau[2]`)
* La taille d'un tableau peut être obtenue en utilisant la propriété `length` (exemple: `unTableau.length`)
* La méthode de classe `arraycopy` de `System` permet de copier efficacement un tableau

.Exemples de manipulations de tableaux
[source,java,indent=0]
----
include::{tstdir}/base/ArrayTest.java[tag=base-arrays]
----
<1> les tableaux `arrayOfFiveZeros` et `anArray` contiennent les mêmes éléments mais ne sont pas identiques, i.e. ils ne référencent pas le même objet
<2> les tableaux `anArray` et `theSameArray` sont identiques, i.e. ils référencent le même objet
<3> comme `anArray` et `theSameArray` sont identiques, la modification est visible par l'intermédiaire des deux références
<4> même cas que 1
<5> `theSameArray` référence maintenant `anotherArray` donc `theSameArray` et `anotherArray` sont identiques mais `theSameArray` et `anArray` ne le sont plus
<6> comme `theSameArray` et `anotherArray` sont identiques, la modification est visible par l'intermédiaire des deux références mais `anArray` n'a pas été modifié

== Opérateurs
Un _opérateur_ est une suite de symboles réalisant une opération spécifique.

.Opérateurs par ordre de priorité
[sidebar]
****
* `expr++` `expr--` (incrémentation/décrémentation post-fixée)
* `++expr` `--expr` (incrémentation/décrémentation pré-fixée) `+expr` (+ unaire) `-expr` (- unaire) `~` (complément bit à bit) `!` (négation)
* `*` (multiplication) `/` (division) `%` (reste)
* `+` (addition/concaténation de chaînes) `-` (soustraction)
* `<<` `>>` `>>>` (décalage à gauche/à droite/à droite non signé)
* `<` `>` `<=` `>=` (comparaison) `instanceof` (comparaison à un type)
* `==` `!=` (égalité/inégalité)
* `&` (ET bit à bit)
* `^` (OU exclusif bit à bit)
* `|` (OU bit à bit)
* `&&` (ET logique)
* `||` (OU logique)
* `? :` (conditionnel ternaire)
* `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `|=` `<<=` `>>=` `>>>=` (affectation)
****

NOTE: {tutourl}/java/nutsandbolts/operators.html[Operators]

== Expressions, instructions et blocs
* Une _expression_ est une construction conforme à la syntaxe du langage, formée de variables, d'opérateurs et d'appels de méthode qui est évaluée en une valeur unique.
* Une _instruction_ est une _unité d'exécution_.
En Java, chaque instruction est suivie d'un `;`.
* Un _bloc_ est un groupe d'instructions entre accolades et peut être utilisé à tout endroit où une instruction peut l'être.

NOTE: {tutourl}/java/nutsandbolts/expressions.html[Expressions, Statements, and Blocks],
{jlsurl}/jls-15.html[Expressions],
{jlsurl}/jls-14.html[Blocks and Statements]

== Structures de contrôle
//TODO à compléter
À compléter

NOTE: {tutourl}/java/nutsandbolts/flow.html[Control Flow Statements],
{jlsurl}/jls-14.html[Blocks and Statements]
